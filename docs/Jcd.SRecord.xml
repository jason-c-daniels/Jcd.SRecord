<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Jcd.SRecord</name>
    </assembly>
    <members>
        <member name="M:Jcd.SRecord.Extensions.CharExtensions.IsHexDigit(System.Char)">
            <summary>
             Returns true if a character is a hexadecimal digit.
            </summary>
            <param name="character">the character to inspect.</param>
            <returns>True if the character</returns>
        </member>
        <member name="M:Jcd.SRecord.Extensions.CharExtensions.ThrowArgumentExceptionIfNotValidForSRecordComment(System.Char)">
            <summary>
            Throws an ArgumentException if the character can't be used for an SRecord comment.
            </summary>
            <param name="character">the character to check.</param>
            <exception cref="T:System.ArgumentException">Thrown if the character is invalid.</exception>
        </member>
        <member name="T:Jcd.SRecord.Extensions.HexStringConversions">
            <summary>
            A set of extension methods to help in converting
            to and from hexadecimal representations of bytes 
            </summary>
        </member>
        <member name="M:Jcd.SRecord.Extensions.HexStringConversions.HexStringToBytes(System.String)">
            <summary>
            Converts a sequence of hexadecimal characters into the equivalent bytes. 
            </summary>
            <param name="hexString">the text to convert.</param>
            <returns>The sequence of bytes represented by the hex string.</returns>
        </member>
        <member name="M:Jcd.SRecord.Extensions.HexStringConversions.BytesToHexString(System.Collections.Generic.IEnumerable{System.Byte},System.Boolean)">
            <summary>
            Convert a sequence of bytes into a string of hexadecimal values. 
            </summary>
            <param name="bytes">the bytes to convert</param>
            <param name="makeUppercase">makes the A-F range uppercase when true, lowercase otherwise</param>
            <returns>The hexadecimal text representation</returns>
        </member>
        <member name="T:Jcd.SRecord.IO.ISRecordLineFormatter">
            <summary>
            Defines the interface needed to format an <c>SRecordLine</c>
            </summary>
        </member>
        <member name="M:Jcd.SRecord.IO.ISRecordLineFormatter.Format(Jcd.SRecord.Parsers.SRecordLine)">
            <summary>
            Formats an <c>SRecordLine</c> as a line of text.
            </summary>
            <param name="line">the line to format.</param>
            <returns>
            Null indicates no line was generated. String.Empty indicates
            that a blank line was generated. <c>SRecordLineWriter</c>
            will discard null results. Depending on options settings, it may write
            blank lines.
            </returns>
        </member>
        <member name="T:Jcd.SRecord.IO.SRecordLineFormatter">
            <summary>
            Encapsulates the logic necessary to format an <c>SRecordLine</c>
            as a line of text.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.DefaultFormatter">
            <summary>
            Gets the default instance of <c>SRecordLineFormatter</c> 
            </summary>
        </member>
        <member name="P:Jcd.SRecord.IO.SRecordLineFormatter.CurrentOptions">
            <summary>
            Gets the currently configured options.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.IO.SRecordLineFormatter.SRecordFormatter">
            <summary>
            Gets the currently configured SRecordFormatter
            </summary>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineFormatter.#ctor(System.Nullable{Jcd.SRecord.IO.SRecordLineFormatter.Options},Jcd.SRecord.SRecordFormatter)">
            <summary>
            Constructs an instance of <c>SRecordLineFormatter</c> with the specified
            options and SRecordFormatter.
            </summary>
            <param name="options">The options to use, if null, <c>Options.DefaultOptions</c> is used.</param>
            <param name="sRecordFormatter">The SRecordFormatter to use. If null, <c>SRecordFormatter.UppercaseHex</c> is used.</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineFormatter.Format(Jcd.SRecord.Parsers.SRecordLine)">
            <inheritdoc />
        </member>
        <member name="T:Jcd.SRecord.IO.SRecordLineFormatter.Options">
            <summary>
            Represents the formatting options desired when writing <c>SRecordLine</c> contents
            to an <c>SRecordLineWriter</c>.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.EmitOriginalText">
            <summary>
            Tells the formatter to ignore all other directives, and just emit the original line of text.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.EmitComment">
            <summary>
            Tells the formatter if end of line comments should be emitted.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.EmitSRecordContent">
            <summary>
            Tells the formatter to emit the SRecord when present. This is usually true.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.EmitSpaceBeforeEndOfLineComment">
            <summary>
            Tells the formatter if a space should be emitted before an end of line comment.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.EmitErrorLineAsCommentLine">
            <summary>
            Indicates if the formatter should emit an error line as a commented out line.
            In order for a comment line to be emitted, EmitComment must also be true.
            If false, a blank line or null will be generated for error lines (depending on blank line handling).
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.EmitBlankLineAsEmptyString">
            <summary>
            Indicates if the formatter should emit a blank line as an empty string or null.
            When false, lines that would format to an empty string, become null instead.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.CommentCharacter">
            <summary>
            The character to use when emitting a comment.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineFormatter.Options.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Char)">
            <summary>
            Constructs a set of options to control the behavior of SRecordLineFormatter.
            </summary>
            <param name="emitSRecordContent">Tells the formatter to emit the SRecord when present.</param>
            <param name="emitComment">Tells the formatter if end of line comments should be emitted.</param>
            <param name="emitSpaceBeforeEndOfLineComment"></param>
            <param name="emitOriginalText">Tells the formatter to ignore all other directives, and just emit the original line of text.</param>
            <param name="emitBlankLineAsEmptyString"></param>
            <param name="emitErrorLineAsCommentLine"></param>
            <param name="commentCharacter"></param>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.OnlyEmitSRecordData">
            <summary>
            A convenience instance that is configured to only emit <c>SRecord</c> line and only the <c>SRecord</c> data.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.OnlyEmitCommentData">
            <summary>
            A convenience instance that is configured to only emit comment data.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.EmitSRecordAndCommentData">
            <summary>
            A convenience instance that is configured to emit <c>SRecord</c> line and comment data.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.EmitSRecordAndCommentDataWithSpace">
            <summary>
            A convenience instance that is configured to emit <c>SRecord</c>
            line and comment data. For end of line comments after <c>SRecord</c>
            data, a space is inserted before the comment character.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.CommentOutErrorLines">
            <summary>
            A convenience instance that is configured to emit <c>SRecord</c> line and comment data.
            As well <c>SRecordLine</c>s flagged as having an error will be emitted as commented out
            lines. (SRecordLine.OriginalLine is used, otherwise preserving the whole line.) 
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineFormatter.Options.OnlyEmitOriginalText">
            <summary>
            A convenience instance that is configured to only emit the original text.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.IO.SRecordLineFormatter.Options.DefaultOptions">
            <summary>
            See <c>EmitSRecordAndCommentDataWithSpace</c>
            </summary>
        </member>
        <member name="T:Jcd.SRecord.IO.SRecordLineParser">
            <summary>
            Provides a simplistic manner of parsing SRecords
            </summary>
        </member>
        <member name="P:Jcd.SRecord.IO.SRecordLineParser.CommentCharacters">
            <summary>
            Gets a copy of the comment characters in use.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineParser.DefaultCommentCharacters">
            <summary>
            The default set of comment characeters we'll parse.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineParser.Default">
            <summary>
            A default instance configured with reasonable, flexible, defaults. It should parse most any line.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineParser.NoComments">
            <summary>
            A default instance configured with reasonable, flexible, defaults. It should parse most any line.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.IO.SRecordLineParser.AllowComments">
            <summary>
            Indicates if comments are allowed. To Allow comments pass a set of
            recognized comment characters in to the constructor. 
            </summary>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineParser.#ctor(Jcd.SRecord.SRecordParser,System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Constructs an SRecordLineParser from an <c>SRecordParser</c>
            and an optional set of comment characters.
            </summary>
            <param name="sRecordParser"></param>
            <param name="commentCharacters"></param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineParser.Parse(System.Int32,System.String)">
            <summary>
            Parses a line of text into an SRecordLine.
            </summary>
            <param name="lineNumber">The line number.</param>
            <param name="lineOfText">The raw text.</param>
            <returns>an SRecordLine describing the parsing results.</returns>
        </member>
        <member name="T:Jcd.SRecord.IO.SRecordLineReader">
            <summary>
            A forward only SRecordLine stream/string reader.
            This class always disposes its Stream/StreamReader when disposed.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.IO.SRecordLineReader.CurrentLine">
            <summary>
            The line number of the most recently read line.
            This is 0 if nothing has been read and number of the last line in the file,
            if all lines have been read.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineReader.#ctor(System.String,Jcd.SRecord.Parsers.ISRecordLineParser)">
            <summary>
            Constructs an <c>SRecordLineReader</c> from a block of text. The encoding is assumed to be UTF8.
            </summary>
            <param name="linesOfText">the block of text.</param>
            <param name="parser">the line parser.</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineReader.#ctor(System.String,System.Text.Encoding,Jcd.SRecord.Parsers.ISRecordLineParser)">
            <summary>
            Constructs an <c>SRecordLineReader</c> from a block of text. The encoding is assumed to be UTF8.
            </summary>
            <param name="linesOfText">the block of text.</param>
            <param name="parser">the line parser.</param>
            <param name="encoding">The encoding to use for linesOfText.</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineReader.#ctor(System.IO.Stream,Jcd.SRecord.Parsers.ISRecordLineParser)">
            <summary>
            Constructs an <c>SRecordLineReader</c> from a stream.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="parser">The parser to use</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineReader.#ctor(System.IO.Stream,System.Text.Encoding,Jcd.SRecord.Parsers.ISRecordLineParser)">
            <summary>
            Constructs an <c>SRecordLineReader</c> from a stream.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="parser">The parser to use</param>
            <param name="encoding">The text encoding to use.</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineReader.#ctor(System.IO.StreamReader,Jcd.SRecord.Parsers.ISRecordLineParser)">
            <summary>
            Constructs an <c>SRecordLineReader</c> from a stream reader and line parser.
            </summary>
            <param name="streamReader">The reader</param>
            <param name="parser">The parser</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineReader.ReadRemainingLines">
            <summary>
            Get an enumerable of <c>SRecordLine</c>s from the input stream from the current position.
            </summary>
            <returns>an enumerable of <c>SRecordLine</c>s from the input stream</returns>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineReader.ReadRemainingLinesAsync">
            <summary>
            Get an enumerable of <c>SRecordLine</c>s from the input stream, asynchronously
            </summary>
            <returns>an enumerable of <c>SRecordLine</c>s from the input stream</returns>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineReader.ReadLine">
            <summary>
            Reads an <c>SRecordLine</c> from the stream.
            </summary>
            <returns>The <c>SRecordLine</c>, null if end of stream has been reached.</returns>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineReader.ReadLineAsync">
            <summary>
            Reads an <c>SRecordLine</c> from the stream.
            </summary>
            <returns>The <c>SRecordLine</c>, null if end of stream has been reached.</returns>
        </member>
        <member name="P:Jcd.SRecord.IO.SRecordLineReader.EndOfData">
            <summary>
            Indicates if all of the data has been read.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineReader.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineType.Comment">
            <summary>
            A single line comment.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineType.SRecord">
            <summary>
            An SRecord without a comment.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineType.SRecordWithEndOfLineComment">
            <summary>
            An SRecord with end of line comment.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineType.Blank">
            <summary>
            A blank line (Empty or all whitespace.)
            </summary>
        </member>
        <member name="F:Jcd.SRecord.IO.SRecordLineType.Error">
            <summary>
             Indicates if some error was detected while parsing the line.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineType.Equals(Jcd.SRecord.IO.SRecordLineType)">
            <summary>
            Compares this instance to another.
            </summary>
            <param name="other">The other instance to compare to.</param>
            <returns>true if equal.</returns>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineType.Equals(System.Object)">
            <summary>
            Compares this instance to another object.
            </summary>
            <param name="other">The other instance to compare to.</param>
            <returns>true if equal.</returns>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineType.GetHashCode">
            <summary>
            Generates a hashcode for the instance.
            </summary>
            <returns>The hashcode</returns>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineType.op_Equality(Jcd.SRecord.IO.SRecordLineType,Jcd.SRecord.IO.SRecordLineType)">
            <summary>
            Compares two instances of <c>SRecordLineType</c> for equality.
            </summary>
            <param name="left">The left hand side of the comparison.</param>
            <param name="right">The right hand side of the comparison.</param>
            <returns>True if equal</returns>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineType.op_Inequality(Jcd.SRecord.IO.SRecordLineType,Jcd.SRecord.IO.SRecordLineType)">
            <summary>
            Compares two instances of <c>SRecordLineType</c> for inequality.
            </summary>
            <param name="left">The left hand side of the comparison.</param>
            <param name="right">The right hand side of the comparison.</param>
            <returns>True if not equal</returns>
        </member>
        <member name="T:Jcd.SRecord.IO.SRecordLineWriter">
            <summary>
            Writes <c>SRecordLine</c>s to a stream.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineWriter.#ctor(System.IO.Stream,Jcd.SRecord.IO.ISRecordLineFormatter)">
            <summary>
            Constructs an instance from a stream and line formatter. 
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="lineFormatter">The line formatter.</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineWriter.#ctor(System.IO.Stream,System.Text.Encoding,Jcd.SRecord.IO.ISRecordLineFormatter)">
            <summary>
            Constructs an instance from a stream, an encoding, and line formatter. 
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="encoding">The encoding to use.</param>
            <param name="lineFormatter">The line formatter.</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineWriter.#ctor(System.IO.StreamWriter,Jcd.SRecord.IO.ISRecordLineFormatter)">
            <summary>
            Constructs an instance from a <c>StreamWriter</c> and an <c>ISRecordLineFormatter</c>
            </summary>
            <param name="streamWriter">The StreamWriter</param>
            <param name="lineFormatter">The line formatter</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either parameter is null.</exception>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineWriter.WriteLine(Jcd.SRecord.Parsers.SRecordLine)">
            <summary>
            Format and write an SRecordLine to the stream.
            </summary>
            <param name="line">the line to format and write.</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineWriter.WriteLineAsync(Jcd.SRecord.Parsers.SRecordLine)">
            <summary>
            Formats and writes a line to the stream, asynchronously.
            </summary>
            <param name="line">The line to write.</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineWriter.WriteLines(System.Collections.Generic.IEnumerable{Jcd.SRecord.Parsers.SRecordLine})">
            <summary>
            Writes a set of lines to the stream.
            </summary>
            <param name="lines">The lines to write.</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineWriter.WriteLinesAsync(System.Collections.Generic.IEnumerable{Jcd.SRecord.Parsers.SRecordLine})">
            <summary>
            Writes a set of lines to a stream, asynchronously.
            </summary>
            <param name="lines">The lines to write.</param>
        </member>
        <member name="M:Jcd.SRecord.IO.SRecordLineWriter.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:Jcd.SRecord.Parsers.ISRecordLineParser.Parse(System.Int32,System.String)">
            <summary>
            Parses a line of text into an SRecordLine.
            </summary>
            <param name="lineNumber">The line number.</param>
            <param name="lineOfText">The raw text.</param>
            <returns>an SRecordLine describing the parsing results.</returns>
        </member>
        <member name="T:Jcd.SRecord.Parsers.SRecordLine">
            <summary>
            Represents a single line read and parsed from an <c>SRecordLineReader</c>.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.Parsers.SRecordLine.LineNumber">
            <summary>
            The line in the file where the text was found.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.Parsers.SRecordLine.SRecord">
            <summary>
            The SRecord parsed from the line (if any) 
            </summary>
        </member>
        <member name="P:Jcd.SRecord.Parsers.SRecordLine.Comment">
            <summary>
            The comment text (lines starting with a ';' '#' ...etc are comment lines.) 
            </summary>
        </member>
        <member name="P:Jcd.SRecord.Parsers.SRecordLine.LineType">
            <summary>
            True if the line recognized as an SRecord and/or comment. False otherwise.
            When false, OriginalLine should be populated with the extracted line of text, without end of line character(s).
            Also, ErrorMessage should be populated with the error encountered while trying to parse the line. 
            </summary>
        </member>
        <member name="P:Jcd.SRecord.Parsers.SRecordLine.OriginalLine">
            <summary>
            The original line of text. A well constructed parser will always provide this. The default one does.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.Parsers.SRecordLine.ErrorMessage">
            <summary>
            Contains a parser specific error message associated with attempting to parse this line.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.Parsers.SRecordLine.Exception">
            <summary>
            An exception that happened while trying to parse the line of text.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.Parsers.SRecordLine.#ctor(System.Int32,Jcd.SRecord.IO.SRecordLineType,Jcd.SRecord.SRecord,System.String,System.String,System.String,System.Exception)">
            <summary>
            Constructs an instance of an <c>SRecordLine</c>
            </summary>
            <param name="lineNumber">The line number in the file.</param>
            <param name="lineType">The lineType of line.</param>
            <param name="sRecord">the parsed and validated <c>SRecord</c> instance.</param>
            <param name="comment">The comment text, without the comment character.</param>
            <param name="originalLine">The original full text of the line.</param>
            <param name="errorMessage">An error message, populated when lineType is false.</param>
            <param name="exception">An exception that occurred during parsing of the SRecord entry.</param>
        </member>
        <member name="T:Jcd.SRecord.SRecord">
            <summary>
            Represents a single SRecord entry in an srecord file. This is an immutable type. To edit the contents, create a new one with the altered data buffer, address, and/or type.
            </summary>
            <remarks>
            Further reading about the SRecord format can be done
            <see href="https://manpages.ubuntu.com/manpages/trusty/man5/srec.5.html"> at the Ubuntu manpage</see>
            and <see href="https://en.wikipedia.org/wiki/SREC_(file_format)">the wikipedia page</see>.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecord.CheckSumByteLength">
            <summary>
            The length of the checksum, in bytes.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecord.CountByteLength">
            <summary>
            The length of the count in bytes
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecord.KeyCharLength">
            <summary>
            The length of the record key in characters.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecord.MaxValueForCount">
            <summary>
            The maximum value for the count field. 
            </summary>
        </member>
        <member name="P:Jcd.SRecord.SRecord.Type">
            <summary>
            The type of SRecord
            </summary>
        </member>
        <member name="P:Jcd.SRecord.SRecord.CountOfRemainingBytes">
            <summary>
            The total count of the address, data, and checksum bytes.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.SRecord.Address">
            <summary>
            If applicable, the address for data to be written to, or in some cases, a count of preceding records.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.SRecord.EndAddress">
            <summary>
            The computed address of the last byte of data contained in this record.
            For records with 0 data length, this will contain the same value as Address. 
            </summary>
        </member>
        <member name="P:Jcd.SRecord.SRecord.Data">
            <summary>
            The data to be loaded into the address. (or in S0's case a descriptor for the file.)
            </summary>
        </member>
        <member name="P:Jcd.SRecord.SRecord.Checksum">
            <summary>
            The checksum for the type, address, and data.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.SRecord.#ctor(Jcd.SRecord.SRecordType,System.UInt32,System.Byte[])">
            <summary>
            Constructs a mew SRecord instance.
            </summary>
            <param name="type">The type descriptor for the SRecord</param>
            <param name="address">The data for the address field.</param>
            <param name="data">The data for the data field, if any.</param>
        </member>
        <member name="M:Jcd.SRecord.SRecord.ComputeChecksum(Jcd.SRecord.SRecordType,System.Byte,System.UInt32,System.Byte[])">
            <summary>
            Computes the checksum for the record.
            </summary>
            <param name="type">The type descriptor for the record.</param>
            <param name="count">The count of bytes following</param>
            <param name="address">The data for the address field.</param>
            <param name="data">The data for the data field, if any.</param>
            <returns>The checksum</returns>
        </member>
        <member name="M:Jcd.SRecord.SRecord.ComputeChecksum(System.Byte[])">
            <summary>
            Computes the checksum for the concatenated bytes contained in the address
            and data fields.
            </summary>
            <param name="countAddressAndDataBytes">The concatenated list of bytes from the address and data.</param>
            <returns>The checksum</returns>
        </member>
        <member name="T:Jcd.SRecord.SRecordFormatter">
            <summary>
            Encapsulates the formatting logic required to emit a single SRecord
            with consistent hex value casing.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.SRecordFormatter.EmitHexNumbersInUpperCase">
            <summary>
            Indicates if the hex numbers should be uppercase (true) or lowercase (false)
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordFormatter.UppercaseHex">
            <summary>
            And instance preconfigured to emit uppercase hex values.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordFormatter.LowercaseHex">
            <summary>
            An instance preconfigured to emit lowercase hex values.
            </summary>
        </member>
        <member name="P:Jcd.SRecord.SRecordFormatter.Default">
            <summary>
            The default (uppercase) method of emitting an SRecord.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.SRecordFormatter.Format(Jcd.SRecord.SRecord)">
            <summary>
            Converts an SRecord into its ASCII-HEX representation.
            </summary>
            <param name="sRecord">the record to format</param>
            <returns>The formatted string (S0030000FC...etc)</returns>
        </member>
        <member name="T:Jcd.SRecord.SRecordParser">
            <summary>
            Provides facilities for parsing the textual SRecord format into its
            binary representation.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.SRecordParser.#ctor(System.Collections.Generic.IDictionary{System.String,Jcd.SRecord.SRecordType})">
            <summary>
            Constructs an SRecordParser from a defined sRecord type lookup table.
            </summary>
            <param name="typeLookup"></param>
        </member>
        <member name="M:Jcd.SRecord.SRecordParser.Parse(System.String)">
            <summary>
            Parses a line of text into an <c>SRecord, ignoring trailing whitespace.</c>
            </summary>
            <param name="lineOfText">The line of text to parse.</param>
            <returns>An <c>SRecord</c> instance if it was successfully parsed.</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Jcd.SRecord.SRecordParser.TryParse(System.String,Jcd.SRecord.SRecord@)">
            <summary>
            Tries parsing a line of text into an <c>SRecord</c>
            </summary>
            <param name="lineOfText">the text to try parsing.</param>
            <param name="sRecord">The result of parsing. null if not parsed.</param>
            <returns>true if successful</returns>
        </member>
        <member name="F:Jcd.SRecord.SRecordParser.Strict">
            <summary>
            An instance configured to use Strict definitions.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordParser.Flexible">
            <summary>
            An instance configured to use Flexible definitions.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordParser.Default">
            <summary>
            An default instance. This is the same as Flexible.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.SRecordParser.Create(System.Byte)">
            <summary>
            Creates a new instance of an SRecordParser configured to parse records
            containing the configured maxDataBytesPerRecord.
            </summary>
            <remarks>When maxDataBytesPerRecord is greater than 250, the Flexible instance is used instead of creating a new one.</remarks>
            <param name="maxDataBytesPerRecord"></param>
            <returns></returns>
        </member>
        <member name="T:Jcd.SRecord.SRecordType">
            <summary>
            Represents the information required to identify and process various types of SRecords
            <see href="https://manpages.ubuntu.com/manpages/trusty/man5/srec.5.html">
            as documented here
            </see>
            </summary>
        </member>
        <member name="M:Jcd.SRecord.SRecordType.CreateLookup(System.Byte)">
            <summary>
            Creates a lookup table of <c>SRecordType</c>s.
            </summary>
            <param name="dataBytesPerRecord">The number of data bytes you want any S1,S2, or S3 record to hold.</param>
            <returns>Returns a lookup table for record types.</returns>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.KeyLength">
            <summary>
            The length of the key in characters.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.RecordStartCharacter">
            <summary>
            The mandatory character that all SRecord types must start with 'S'. 
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Key">
            <summary>
            The key for the type.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.AddressLengthInBytes">
            <summary>
            The number of bytes used to represent the address.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.MaximumDataBytesAllowed">
            <summary>
            The maximum number of bytes allowed in the data section for this type.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.IsValid">
            <summary>
            Indicates if the type is valid and recognized. 
            </summary>
            <remarks>
            This is set by whatever is constructing the type. Usually this will be set
            at compile time. See, <c>Strict</c> and <c>Flexible</c> for examples.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.RequiresSpecialHandling">
            <summary>
            Indicates if the type requires special (i.e. non-standard handling. e.g. S4)
            </summary>
        </member>
        <member name="M:Jcd.SRecord.SRecordType.#ctor(System.String,System.Byte,System.Byte,System.Boolean,System.Boolean)">
            <summary>
            Constructs an SRecordType, which identifies how to properly process and/or parse
            an SRecord of the specified type, provided the key, address length, and
            maximum data bytes allowed.
            </summary>
            <remarks>
            This constructor is only intended to be used by people who will use it correctly.
            Typically you'll want to use Strict.FromKey or Flexible.FromKey instead.
            </remarks>
            <param name="key">The two character SRecord identifier. (S0..S9)</param>
            <param name="addressLengthInBytes">The byte length of the address</param>
            <param name="maximumDataBytesAllowed">The maximum number of data bytes allowed.</param>
            <param name="requiresSpecialHandling">Indicates if the type requires special handling. (S4 does)</param>
            <param name="isValid">Indicates if parsing recognized the key.</param>
        </member>
        <member name="M:Jcd.SRecord.SRecordType.#ctor(System.String,System.Byte,System.Boolean,System.Boolean)">
            <summary>
            Constructs an SRecordType, which identifies how to properly process and/or parse
            an SRecord of the specified type, provided the key, address length. The maximum
            data length is computed from the following formula:
            MaximumDataBytesAllowed = SRecord.MaxValueForCount - SRecord.CheckSumByteLength - addressLengthInBytes;
            </summary>
            <remarks>
            This constructor is only intended to be used by people who will use it correctly.
            Typically you'll want to use Strict.FromKey or Flexible.FromKey instead.
            </remarks>
            <param name="key">The two character SRecord identifier. (S0..S9)</param>
            <param name="addressLengthInBytes">The byte length of the address</param>
            <param name="requiresSpecialHandling">Indicates if the type requires special handling. (S4 does)</param>
            <param name="isValid">Indicates if parsing recognized the key.</param>
        </member>
        <member name="T:Jcd.SRecord.SRecordType.Flexible">
            <summary>
            Provides a collection and lookup mechanism for instances of <see cref="T:Jcd.SRecord.SRecordType"/>
            configured to accept a flexible number of data bytes per record. The exact amount
            allowed varies per type and is 254 bytes minus the address length in bytes, for S0,
            S1, S2, S3, and S4. NOTE: S4 types always require special, implementation defined, handling.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.MaxDataLength">
            <summary>
            The maximum data any data bearing record may have
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.S0">
            <summary>
            The identifier for S0 records. Address is 2 bytes, should always be 0. Maximum data bytes allowed 252 bytes.
            </summary>
            <remarks>
            This record contains vendor specific ASCII text comment represented as a series of hex digit pairs.
            There is a spec, seldom conformed to, outlined in the <see href="https://manpages.ubuntu.com/manpages/trusty/man5/srec.5.html">Ubuntu manpage</see>.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.S1">
            <summary>
            The identifier for S1 records. Address is 2 bytes. Maximum data bytes allowed 252 bytes.
            </summary>
            <remarks>
            This record type contains data that starts at the 16-bit address field.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.S2">
            <summary>
            The identifier for S2 records. Address is 3 bytes. Maximum data bytes allowed 251 bytes.
            </summary>
            <remarks>
            This record type contains data that starts at a 24-bit address.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.S3">
            <summary>
            The identifier for S3 records. Address is 4 bytes. Maximum data bytes allowed 250 bytes.
            </summary>
            <remarks>
            This record type contains data that starts at a 32-bit address.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.S4">
            <summary>
            The identifier for S4 records. Address is 4 bytes. Maximum data bytes allowed 250 bytes.
            </summary>
            <remarks>
            Special handling required. This is vendor defined/reserved.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.S5">
            <summary>
            The identifier for S5 records. Address is 2 bytes. No data allowed.
            </summary>
            <remarks>
            This record type is used to contain a 16-bit count of all S1, S2, or S3 records,
            stored in the address field. There are no data bytes for this record type.
            This record is used if the record count is less than or equal to 65,535 (0xFFFF).
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.S6">
            <summary>
            The identifier for S6 records. Address is 3 bytes. No data allowed.
            </summary>
            <remarks>
            This record type is used to contain a 24-bit count of all S1, S2, or S3 records,
            stored in the address field. There are no data bytes for this record type.
            This record is used if the record count is less than or equal to 16,777,215 (0xFFFFFF) and 
            greater than 65,535 (0xFFFF) records.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.S7">
            <summary>
            The identifier for S7 records. Address is 4 bytes.  No data allowed.
            This is used to terminate a series of S3 records. 
            </summary>
            <remarks>
            If an SRecord file is only used to program a memory device and the execution location
            is ignored, then an address of zero could be used.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.S8">
            <summary>
            The identifier for S8 records. Address is 3 bytes. No data allowed.
            This is used to terminate a series of S2 records.
            </summary>
            <remarks>
            If an SRecord file is only used to program a memory device and the execution location
            is ignored, then an address of zero could be used.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.S9">
            <summary>
            The identifier for S8 records. Address is 3 bytes. Maximum data bytes allowed 32 bytes.
            </summary>
            <remarks>
            This is used to terminate a series of S1 records. If a SRecord file is only used to program
            a memory device and the execution location is ignored, then an address of zero could be used.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Flexible.TypeLookup">
            <summary>
            A key-based lookup for known Flexible (250-252 byte data max depending on record type) <c>SRecordType</c> instances.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.SRecordType.Flexible.FromKey(System.String)">
            <summary>
            Given a key, return an SRecordType instance describing it.
            Invalid keys will return  
            </summary>
            <param name="key"></param>
            <returns>A matching <c>SRecordType</c> or a new instance with IsValid set to false.</returns>
        </member>
        <member name="T:Jcd.SRecord.SRecordType.Strict">
            <summary>
            Provides a collection and lookup mechanism for instances of <see cref="T:Jcd.SRecord.SRecordType"/>
            configured to accept a maximum of 32 data bytes per record for S0, S1, S2, S3, and S4
            record types. NOTE: S4 types always require special, implementation defined, handling.
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.MaxDataLength">
            <summary>
            The maximum data any data bearing record may have
            </summary>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.S0">
            <summary>
            The identifier for S0 records. Address is 2 bytes, should always be 0. Maximum data bytes allowed 32 bytes.
            </summary>
            <remarks>
            This record contains vendor specific ASCII text comment represented as a series of hex digit pairs.
            There is a spec, seldom conformed to, outlined in the <see href="https://manpages.ubuntu.com/manpages/trusty/man5/srec.5.html">Ubuntu manpage</see>.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.S1">
            <summary>
            The identifier for S1 records. Address is 2 bytes. Maximum data bytes allowed 32 bytes.
            </summary>
            <remarks>
            This record type contains data that starts at the 16-bit address field.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.S2">
            <summary>
            The identifier for S2 records. Address is 3 bytes. Maximum data bytes allowed 32 bytes.
            </summary>
            <remarks>
            This record type contains data that starts at a 24-bit address.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.S3">
            <summary>
            The identifier for S3 records. Address is 4 bytes. Maximum data bytes allowed 32 bytes.
            </summary>
            <remarks>
            This record type contains data that starts at a 32-bit address.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.S4">
            <summary>
            The identifier for S4 records. Address is 4 bytes. Maximum data bytes allowed 32 bytes.
            </summary>
            <remarks>
            Special handling required. This is vendor defined/reserved.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.S5">
            <summary>
            The identifier for S5 records. Address is 2 bytes. No data allowed.
            </summary>
            <remarks>
            This record type is used to contain a 16-bit count of all S1, S2, or S3 records,
            stored in the address field. There are no data bytes for this record type.
            This record is used if the record count is less than or equal to 65,535 (0xFFFF).
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.S6">
            <summary>
            The identifier for S6 records. Address is 3 bytes. No data allowed.
            </summary>
            <remarks>
            This record type is used to contain a 24-bit count of all S1, S2, or S3 records,
            stored in the address field. There are no data bytes for this record type.
            This record is used if the record count is less than or equal to 16,777,215 (0xFFFFFF) and 
            greater than 65,535 (0xFFFF) records.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.S7">
            <summary>
            The identifier for S7 records. Address is 4 bytes. No data allowed.
            This is used to terminate a series of S3 records. 
            </summary>
            <remarks>
            If an SRecord file is only used to program a memory device and the execution location
            is ignored, then an address of zero could be used.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.S8">
            <summary>
            The identifier for S8 records. Address is 3 bytes.  No data allowed.
            This is used to terminate a series of S2 records.
            </summary>
            <remarks>
            If an SRecord file is only used to program a memory device and the execution location
            is ignored, then an address of zero could be used.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.S9">
            <summary>
            The identifier for S8 records. Address is 3 bytes.  No data allowed.
            </summary>
            <remarks>
            This is used to terminate a series of S1 records. If a SRecord file is only used to program
            a memory device and the execution location is ignored, then an address of zero could be used.
            </remarks>
        </member>
        <member name="F:Jcd.SRecord.SRecordType.Strict.TypeLookup">
            <summary>
            A key-based lookup for known Strict (32 byte data max) <c>SRecordType</c> instances.
            </summary>
        </member>
        <member name="M:Jcd.SRecord.SRecordType.Strict.FromKey(System.String)">
            <summary>
            Given a key, return an SRecordType instance describing it.
            Invalid keys will return  
            </summary>
            <param name="key"></param>
            <returns>A matching <c>SRecordType</c> or a new instance with IsValid set to false.</returns>
        </member>
    </members>
</doc>
